# 我们可以考虑使用动态规划来做这道题，状态可以表示成 (K, N)，其中 K 为鸡蛋数，N 为楼层数，【6，7，8】即三层。
# 当我们从第 X楼扔鸡蛋的时候：
# 如果鸡蛋不碎，那么状态变成 (K, N-X)，即我们鸡蛋的数目不变，但答案只可能在上方的 N-X层楼了。
# PS：细心的读者可能会问，在第i层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第X层楼呀？
# 不必，因为已经包含了。开头说了所求楼层是可以等于 0 的，向上找后，第i层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。

# 如果鸡蛋碎了，那么状态变成 (K-1, X-1)，即我们少了一个鸡蛋，但我们知道答案只可能在第 X 楼下方的 X-1 层楼中了。
# 也就是说，我们把原问题缩小成了一个规模为 (K-1, X-1)的子问题。
# 例如总共 8 层，在第 5 层扔下去没有破碎，则需要在 [6, 7, 8] 层继续做实验，因此区间的大小就是 8 - 5 = 3。
# 由于我们并不知道真正的 F 值，因此我们必须保证鸡蛋碎了之后接下来需要的步数 和 鸡蛋没碎之后接下来需要的步数二者的最大值最小
# 这样就保证了在最坏情况下（也就是无论 F的值如何） dp(K, N) 的值最小。

# 最坏情况下，是这两个子问题的较大者，由于在第 i 层扔下鸡蛋算作一次实验，i 的值在1≤i≤N，对于每一个 i 都对应了一组值的最大值，取这些 i 下的最小值（最优子结构）
# dp(K,N)= min{max{dp(K−1,i−1),dp(K,N−i)}+1}（会超时）    1是在第i层仍的那一次
#         0<=i<=N

# 注意 dp(K - 1, i - 1) 碎和 dp(K, N - i) 不碎这两个函数，把这两个函数看做关于 i 的函数
# 前者随着 i 的增加应该也是单调递增的，而后者随着 i 的增加应该是单调递减的：
#这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。

def superEggDrop(K, N) :
    memo = {}

    def dp(K, N):
        if (K, N) not in memo:
            if K == 1:
                ans= N
            elif N == 0:
                ans= 0
            elif N == 1:
                ans= 1
            # 用二分搜索代替线性搜索
            else:
                lo, hi = 1, N
                while lo +1< hi:
                    mid = lo+(hi-lo) // 2
                    broken = dp(K - 1, mid - 1)  # 碎
                    not_broken = dp(K, N - mid)  # 没碎
                    # res = min(max(碎，没碎) + 1)
                    if broken > not_broken:
                        hi = mid
                    elif broken < not_broken:
                        lo = mid
                    else:
                        lo = hi = mid
                ans = 1 + min(max(dp(K - 1, lo - 1), dp(K, N -lo)),max(dp(K - 1, hi- 1), dp(K, N -hi)))
            memo[(K, N)] = ans
        return memo[(K, N)]
    return dp(K, N)

K = 2
N = 6
print(superEggDrop(K, N))